//
// Created by dinhnambkhn on 27/08/2023.
//
#include <iostream>
#include <ceres/ceres.h>
#include <ceres/rotation.h>
#include "opencv2/opencv.hpp"

//create a reprojection error functor with residual[0] = x_image - project(x_world), residual[1] = y_image - project(y_world)
struct ReprojectionErrorFunctor {
    //constructor
    ReprojectionErrorFunctor(const cv::Point2d &x, const double f, const cv::Point2d &c) : x(x), f(f), c(c) {}
    //operator which calculate residual = x_image - project(x_world) = x_image - f*x_world/z_world + c.x; residual[1] = y_image - project(y_world) = y_image - f*y_world/z_world + c.y
    template<typename T>
    bool operator()(const T *const camera, const T *const point, T *residual) const {
        // X' = R*X + t
        T X[3];
        //transform point from world coordinate to camera coordinate by rotation and translation
        //X = R*X + t
        ceres::AngleAxisRotatePoint(camera, point, X); // R*X
        //X = R*X + t
        X[0] += camera[3];
        X[1] += camera[4];
        X[2] += camera[5];

        // x' = K*X'
        T x_p = f * X[0] / X[2] + c.x;
        T y_p = f * X[1] / X[2] + c.y;

        // residual = x - x'
        residual[0] = T(x.x) - x_p;
        residual[1] = T(x.y) - y_p;
        return true;
    }
    //create a cost function with 6 DOF camera and 3 DOF point, and 2 residual
    static ceres::CostFunction *create(const cv::Point2d &x, const double f, const cv::Point2d &c) {
        return (new ceres::AutoDiffCostFunction<ReprojectionErrorFunctor, 2, 6, 3>(
                new ReprojectionErrorFunctor(x, f, c)));
    }

private:
    const cv::Point2d x; //image point
    const double f; //focal length
    const cv::Point2d c; //principal point [cx, cy]

};

int main()
{
    // c.f. The following dataset were generated by 'image_formation.cpp'.
    const char* input = "/home/dinhnambkhn/3dv_tutorial/bin/data/image_formation%d.xyz";
    int input_num = 5;
    double f = 1000, cx = 320, cy= 240;

    // Load 2D points observed from multiple views
    std::vector<std::vector<cv::Point2d>> xs;
    for (int i = 0; i < input_num; i++)
    {
        FILE* fin = fopen(cv::format(input, i).c_str(), "rt");
        if (fin == nullptr) return -1;
        std::vector<cv::Point2d> pts;
        while (!feof(fin))
        {
            double x, y, w;
            if (fscanf(fin, "%lf %lf %lf", &x, &y, &w) == 3)
                pts.emplace_back(x, y);
        }
        fclose(fin);
        xs.push_back(pts);
        if (xs.front().size() != xs.back().size()) return -1;
    }
    // camera poses
    std::vector<cv::Vec6d> cameras(xs.size());
    // 3D points, initialize with 0,0,5.5, equal to the image point size
    std::vector<cv::Point3d> Xs(xs.front().size(), cv::Point3d(0, 0, 5.5));
    //create a problem
    ceres::Problem ba;
    //add cost function for each point in each image
    for (size_t j = 0; j < xs.size(); j++)
    {
        for (size_t i = 0; i < xs[j].size(); i++)
        {
            //create a cost function with 6 DOF camera and 3 DOF point, and 2 residual
            ceres::CostFunction* cost_func = ReprojectionErrorFunctor::create(xs[j][i], f, cv::Point2d(cx, cy));
            //add residual block to the problem
            auto* camera = (double*)(&(cameras[j]));
            auto* X = (double*)(&(Xs[i]));
            ba.AddResidualBlock(cost_func, nullptr, camera, X);
        }
    }
    //set solver options
    ceres::Solver::Options options;
    options.linear_solver_type = ceres::ITERATIVE_SCHUR;
    options.num_threads = 8;
    options.minimizer_progress_to_stdout = true;
    //solve
    ceres::Solver::Summary summary;
    ceres::Solve(options, &ba, &summary);
    // plot
    cv::Mat img(480, 640, CV_8UC3, cv::Scalar(0, 0, 0));
    for (size_t j = 0; j < xs.size(); j++)
    {
        for (size_t i = 0; i < xs[j].size(); i++)
        {
            // X' = R*X + t
            double X[3];
            ceres::AngleAxisRotatePoint((double*)(&(cameras[j])), (double*)(&(Xs[i])), X);
            X[0] += cameras[j][3];
            X[1] += cameras[j][4];
            X[2] += cameras[j][5];

            // x' = K*X'
            double x_p = f * X[0] / X[2] + cx;
            double y_p = f * X[1] / X[2] + cy;

            // draw
            cv::circle(img, cv::Point(xs[j][i].x, xs[j][i].y), 1, cv::Scalar(0, 0, 255), 2);
            cv::circle(img, cv::Point(x_p, y_p), 1, cv::Scalar(255, 0, 0), 2);
        }
    }
    cv::imshow("bundle adjustment", img);
    cv::waitKey(0);
    return 0;


}